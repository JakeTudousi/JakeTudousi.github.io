<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Ian&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ian&#39;s blog">
<meta property="og:url" content="http://www.1n40.cn/index.html">
<meta property="og:site_name" content="Ian&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ian&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="Ian&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ian&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.1n40.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-看书和看视频学习那个会更好？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/04/看书和看视频学习那个会更好？/" class="article-date">
  <time datetime="2020-02-04T02:07:26.381Z" itemprop="datePublished">2020-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="看书和看视频学习那个会更好？"><a href="#看书和看视频学习那个会更好？" class="headerlink" title="看书和看视频学习那个会更好？"></a>看书和看视频学习那个会更好？</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说来惭愧，我回老家已经90天了，要学习的东西仍没些成就，每日晚睡晚起，实在懒散。前面看《JavaScript高级程序设计》边做笔记边看吧太慢，在医院的时候没电脑实践时不能消化。这是其一，其二是作者老是说些繁枝莫节，或者说是介绍的太过详细。你如果也看过写大部头就知道这种烦恼了。随后我想起下过 智能社 blue 老师讲的《JavaScript视频》，就在b站重新下了份，一股劲看了10/32 。看的时候有一些疑问和感想，记在了便利贴上，拖了几日，这才补上。</p>
<h3 id="lt-script-gt-标签应该放在那里？"><a href="#lt-script-gt-标签应该放在那里？" class="headerlink" title="&lt;script&gt; 标签应该放在那里？"></a>&lt;script&gt; 标签应该放在那里？</h3><p>在红宝书中，尼古拉斯建议读者将其放在body 元素中页面内容的后面，原因是放在head 中，网页会下载完JavaScript代码后才显示html ，对于需要很多JavaScript代码的页面，会出现明显的延迟。<br>尼古拉斯提出的方法你可以在火狐浏览器的火狐主页中看到，你可以先看到先出现一些HTML，之后页面才会加载样式出来，这样一来会带来不好的用户体验。<br>石川老师写JS的时候，将script标签方法了head中，并使用了window.onload函数，这会使得html加载完之后再加载JS。但这样也有它的缺点，即当js中的代码过多时，会出现用户无法触发事件的尴尬状况。<br>那么script到底应该放在那里呢？<br>最好的解决办法应该是  &lt;script&gt; 的 延迟（defer）和 异步（async）属性来解决，但我没有具体的实践经验，因此现在 只好 “纸上谈兵” 了</p>
<h3 id="Function-算是什么类型？"><a href="#Function-算是什么类型？" class="headerlink" title="Function 算是什么类型？"></a>Function 算是什么类型？</h3><p>单纯的只论类型的话，是Object 类型。</p>
<h3 id="匈牙利命名法对前端有无必要？前端的命名规范是什么？"><a href="#匈牙利命名法对前端有无必要？前端的命名规范是什么？" class="headerlink" title="匈牙利命名法对前端有无必要？前端的命名规范是什么？"></a>匈牙利命名法对前端有无必要？前端的命名规范是什么？</h3><p>没有必要。</p>
<ol>
<li>匈牙利命名法是从静态语言发展而来，而JavaScript的变量是弱类型，变量可能会在变量定义后发生类型的改变，从而导致不必要的错误。</li>
<li>经过实践，我看过一些淘宝和百度的js 文件并没有发现这一命名法的应用，说明 JS 中匈牙利命名法是小众的行为。</li>
<li>总结是：是否采用匈牙利命名法要取决于你所在公司团队的习惯、其他的编程习惯也是如此。</li>
</ol>
<h3 id="this-关键字的应用"><a href="#this-关键字的应用" class="headerlink" title="this 关键字的应用"></a>this 关键字的应用</h3><ol>
<li>控件中的使用。</li>
<li>构造函数里，充当隐形的 实例。<h3 id="什么是重点？"><a href="#什么是重点？" class="headerlink" title="什么是重点？"></a>什么是重点？</h3>依靠自己的经验、不断总结慢慢知道的。<h3 id="视频和看书"><a href="#视频和看书" class="headerlink" title="视频和看书"></a>视频和看书</h3></li>
<li>视频见效快、</li>
<li>看书基础牢固</li>
<li>全局变量属于window还是Global 对象？</li>
</ol>
<h3 id="bolg"><a href="#bolg" class="headerlink" title="bolg"></a>bolg</h3><p>前期写blog的时候别要求太多，快速的的写完就是了，不要怕错。另一点是不要想的 事事完美这是不可能的，只当是记录就行了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2020/02/04/看书和看视频学习那个会更好？/" data-id="ck67be8gx0002acvac2dvzvcq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-知识边界" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/04/知识边界/" class="article-date">
  <time datetime="2020-02-04T02:07:23.906Z" itemprop="datePublished">2020-02-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="知识边界"><a href="#知识边界" class="headerlink" title="知识边界"></a>知识边界</h1><ol>
<li>以前要学的：Spring boot、Spring cloud、IDEA</li>
<li>知识的框架，如建房子先立柱子</li>
<li>前端，表现层次、贴近用户</li>
<li>后端，逻辑层次，抽象层次，关心数据和业务</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2020/02/04/知识边界/" data-id="ck67be8h20004acvaruf8picr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch5-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/红宝书阅读笔记ch5-3/" class="article-date">
  <time datetime="2019-12-20T06:26:51.793Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch5-3</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch5-3">红宝书阅读笔记ch5-3</h1>

<p>单体内置对象（Global对象和Math对象）</p>



<h2 id="单体内置对象">单体内置对象</h2>

<p>啥叫单体内置对象？ <br>
    这要分成两部分来说，首先说下什么是内置对象？内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”意思是开发人员不必实例化内置对象，因为它们已经实例化了。例如Object、Array和String。 <br>
    根据前面对内置对象的理解，单体内置对象按我的理解即整个程序中只有一个的内置对象就是单体内置对象，写法就是不用实例化的而且只有一个的对象，可以直接使用这个对象的方法。  </p>



<h3 id="global-对象">Global 对象</h3>

<p>Global （全局）对象，是ECMAScript对象中最特别的一个对象了，因为你根本看不见它，但是它确实是存在的，不属于其他对象的属性和方法，都是它的的属性和方法。事实上，没有全局函数和全局变量；所有在全局作用域中的定义的属性和函数，都是Global 对象的属性。例如 parseFloat ( )、isNaN( )、isFinite( )都是Global 对象的方法。 <br>
    除此之外Global 对象还有其他的方法。  </p>

<ol><li rel="1"><p>URI 编码方法，要进行编码是因为有效的URI不能包括某些字符，如空格。 <br>
    1. encodeURI( )，应用整个URI，将空格编码成 %20 ，除此之外其他不变 <br>
    2. encodeURIComponent( ) ，应用URI中的某一段，将所有非字母和数字的字符进行编码替换。</p></li>
<li rel="2"><p>解码方法 <br>
    1. decodeURI( )，对encodeURI( )进行解码，只会将%20 变成空格。 <br>
    2. decodeURIComponent( )，对encodeURIComponent( )进行解码，可以解任何特殊字符的编码。 <br>
    3. eval( ) 方法，接收一个参数，即要执行的ECMAScript字符串。  它的作用是解释代码字符串。</p></li>
<li rel="3"><p>Global 对象的属性  </p></li>
</ol>

<table><tbody><tr style="font-weight:bold">  <td align="center">属性</td>  <td align="center">说明</td>  <td align="center">属性</td>  <td align="center">说明</td></tr><tr>  <td align="center">undefined</td>  <td align="center">特殊值undefined</td>  <td align="center">Date</td>  <td align="center">构造函数Date</td></tr><tr>  <td align="center">NaN</td>  <td align="center">特殊值NaN</td>  <td align="center">RegExp</td>  <td align="center">构造函数RegExp</td></tr><tr>  <td align="center">Infinity</td>  <td align="center">特殊值Infinity</td>  <td align="center">Error</td>  <td align="center">构造函数Error</td></tr><tr>  <td align="center">Object</td>  <td align="center">构造函数Object</td>  <td align="center">EvalError</td>  <td align="center">构造函数EvalError</td></tr><tr>  <td align="center">Array</td>  <td align="center">构造函数Array</td>  <td align="center">RangeError</td>  <td align="center">构造函数RangeError</td></tr><tr>  <td align="center">Function</td>  <td align="center">构造函数Function</td>  <td align="center">ReferenceError</td>  <td align="center">构造函数ReferenceError</td></tr><tr>  <td align="center">Boolean</td>  <td align="center">构造函数Boolean</td>  <td align="center">SyntaxError</td>  <td align="center">构造函数SyntaxError</td></tr><tr>  <td align="center">String</td>  <td align="center">构造函数String</td>  <td align="center">TypeError</td>  <td align="center">构造函数TypeError</td></tr><tr>  <td align="center">Number</td>  <td align="center">构造函数Number</td>  <td align="center">URIError</td>  <td align="center">构造函数URIError</td></tr></tbody></table>

<ol start="4"><li rel="4"><p>window 对象，Global全局对象作为window对象的一部分加以实现的。即Global属于window对象的一部分。</p></li>
</ol>



<h3 id="math对象">Math对象</h3>

<p>ECMAScript为保存数学公式和信息提供了一个公共位置，即Math对象。与我们在JavaScript中直接编写的计算功能相比，Math对象提供的计算功能执行起来要快得多。</p>

<ol start="1"><li rel="1"><p>Math 对象的属性</p></li>
</ol>

<table><tbody><tr style="font-weight:bold">  <td align="left">属性</td>  <td align="left">说明</td></tr><tr>  <td align="left">Math.E</td>  <td align="left">自然对数的底数，即常量e的值</td></tr><tr>  <td align="left">Math.LN10</td>  <td align="left">10的自然对数</td></tr><tr>  <td align="left">Math.LN2</td>  <td align="left">2的自然对数</td></tr><tr>  <td align="left">Math.LOG2E</td>  <td align="left">以2为底e的对数</td></tr><tr>  <td align="left">Math.LOG10E</td>  <td align="left">以10为底e的对数</td></tr><tr>  <td align="left">Math.PI</td>  <td align="left">π的值</td></tr><tr>  <td align="left">Math.SQRT1_2</td>  <td align="left">1/2的平方根</td></tr><tr>  <td align="left">Math.2</td>  <td align="left">2的平方根</td></tr></tbody></table>

<ol start="2"><li rel="2"><p>min( ) 和 max( ) 方法  ，得出一组数字中的最小值和最大值。</p>

<ol>
<li rel="1"><p>找到数组中的最大或最小值</p></li></ol></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-keyword">var</span> values=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>];
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> max=<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>,values);
</div><div class="hljs-line">        alert(max);
</div></code></pre>

<ol start="3"><li rel="3"><p>舍入方法</p>

<ol>
<li rel="1"><p>Math.ceil( ) ，执行向上舍入，取整数 </p></li>
<li rel="2"><p>Math.florr( )，执行向下舍入，取整数</p></li>
<li rel="3"><p>Math.round( ),四舍五入，取整数</p></li></ol></li>
<li rel="4"><p>random( ) 方法 ，返回一个大于等于0小于1的随机数。</p>

<ol>
<li rel="1"><p>取整数的公式 <br>
值 = Math.floor( Math.random( ) * 可能值的总数 + 第一个可能的值 )</p></li>
<li rel="2"><p>1到10之间的数值 <br>
var num=Math.floor( Math.random() * 10 + 1 );</p></li>
<li rel="3"><p>函数</p></li></ol></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectFrom</span>(<span class="hljs-params">lowerValue, upperValue</span>) </span>{
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> choices = upperValue - lowerValue + <span class="hljs-number">1</span>;
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * choices + lowerValue);
</div><div class="hljs-line">        }
</div><div class="hljs-line">        <span class="hljs-comment">//取数组中的随机一项</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"black"</span>,<span class="hljs-string">"purple"</span>,<span class="hljs-string">"brown"</span>];
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> color=colors[selectFrom(<span class="hljs-number">0</span>,colors.length<span class="hljs-number">-1</span>)];
</div><div class="hljs-line">        <span class="hljs-comment">//取1到10之间的任意一个整数</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> num=selectFrom(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);
</div></code></pre>

<ol start="5"><li rel="5"><p>其他方法</p></li>
</ol>

<table><tbody><tr style="font-weight:bold">  <td align="left">方法</td>  <td align="left">说明</td>  <td align="left">方法</td>  <td align="left">说明</td></tr><tr>  <td align="left">Math.abs(num)</td>  <td align="left">返回num的绝对值</td>  <td align="left">Math.asin(x)</td>  <td align="left">返回x的反正弦值</td></tr><tr>  <td align="left">Math.exp(num)</td>  <td align="left">返回Math.E的num次幂</td>  <td align="left">Math.atan(x)</td>  <td align="left">返回x的反正切值</td></tr><tr>  <td align="left">Math.log(num)</td>  <td align="left">返回num的自然对数</td>  <td align="left">Math.atan2(y,x)</td>  <td align="left">返回有y,x的反正切值</td></tr><tr>  <td align="left">Math.pow(num,power)</td>  <td align="left">返回num的power次幂</td>  <td align="left">Math.cos(x)</td>  <td align="left">返回x的余弦值</td></tr><tr>  <td align="left">Math.sqrt(num)</td>  <td align="left">返回num的平方根</td>  <td align="left">Math.sin(x)</td>  <td align="left">返回x的正弦值</td></tr><tr>  <td align="left">Math.acos(x)</td>  <td align="left">返回x的反余弦值</td>  <td align="left">Math.tan(x)</td>  <td align="left">返回x的正切值</td></tr></tbody></table>

<p>2019.12.20</p></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/12/20/红宝书阅读笔记ch5-3/" data-id="ck67be8ho000cacvaymzk9wem" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch5-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/16/红宝书阅读笔记ch5-2/" class="article-date">
  <time datetime="2019-12-16T14:06:01.817Z" itemprop="datePublished">2019-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch5-2</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch5-2">红宝书阅读笔记ch5-2</h1>

<p>Date类型、RegExp类型、Function类型、基本包装类型</p>



<h2 id="date类型">Date类型</h2>

<ol><li rel="1"><p>Date类型保存的时间精度在1970年之前和之后的一亿年。</p></li>
<li rel="2"><p>获取当前时间只要new一个Date就行了。</p></li>
<li rel="3"><p>根据指定日期和时间来创建日期对象的方法有三种：</p>

<ol>
<li rel="1"><p>传入表示该日期的毫秒数（从1970到该日期所经过的毫秒数） 。</p></li>
<li rel="2"><p>Date.prese( ) ，传入 一个表示日期的字符串，然后该方法尝试返回一个相应日期的毫秒数。</p></li>
<li rel="3"><p>Date.UTC() ，传入一连串表示时间的数字，返回表示日期的毫秒数。</p></li></ol></li>
</ol>

<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-keyword">var</span> now=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-comment">//当前时间</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> oneSecond=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">//一秒</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> prese=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">"11/9/2019"</span>));
</div><div class="hljs-line">        <span class="hljs-comment">//var prese=new Date("11/9/2019"); 和上面那句一毛一样</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> utc=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2005</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">17</span>,<span class="hljs-number">55</span>,<span class="hljs-number">55</span>));
</div><div class="hljs-line">        <span class="hljs-comment">//var utc=new Date(2005,4,5,17,55,55);</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        alert(<span class="hljs-string">"当前时间："</span>+now);
</div><div class="hljs-line">        alert(<span class="hljs-string">"Date.parse(\"11/9/2019\")："</span>+prese);
</div><div class="hljs-line">        alert(<span class="hljs-string">"Date.UTC(2005,4,5,17,55,55)："</span>+utc);
</div><div class="hljs-line">        alert(<span class="hljs-string">"一千毫秒"</span>+oneSecond);
</div></code></pre>

<ol start="4"><li rel="4"><p>Date.valueOf( ) ，返回日期的毫秒数，因此可以用来比较日期值。</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> date1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2007</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);          <span class="hljs-comment">//January 1, 2007</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> date2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2007</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);          <span class="hljs-comment">//February 1, 2007</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        alert(date1 &lt; date2);  <span class="hljs-comment">//true</span>
</div><div class="hljs-line">        alert(date1 &gt; date2);  <span class="hljs-comment">//false</span>
</div></code></pre>

<ol start="5"><li rel="5"><p>日期格式化方法</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-keyword">var</span> dateString =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();       <span class="hljs-comment">//显示星期几、月、日、年</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> timeString=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-comment">//显示时、分、秒和时区</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> localeDateString=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <span class="hljs-comment">//本地区的格式显示显示星期几、月、日、年</span>
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> utcString=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();         <span class="hljs-comment">//完整的UTC日期</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        alert(<span class="hljs-string">"dateString "</span>+dateString.toDateString());
</div><div class="hljs-line">        alert(<span class="hljs-string">"timeString "</span>+dateString.toTimeString());
</div><div class="hljs-line">        alert(<span class="hljs-string">"localeDateString "</span>+dateString.toLocaleDateString());
</div><div class="hljs-line">        alert(<span class="hljs-string">"utcString "</span>+dateString.toUTCString());
</div></code></pre>

<ol start="6"><li rel="6"><p>日期/时间的组件方法 <br>
都是取得和设置日期中值的方法，还有很多方法没列，可上 MDN了解。</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> time=now.getTime();
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> fullYear=now.getFullYear();
</div><div class="hljs-line">        <span class="hljs-keyword">var</span> month=now.getMonth();
</div></code></pre>



<h2 id="regexp-类型">RegExp 类型</h2>

<ol start="1"><li rel="1"><p>语法 <br>
pattern（模式） ,是简单或复杂的正则表达式 <br>
flags（标识），表示正则表达式的行为： <br>
g：全局模式； <br>
i：不区分大小写； <br>
m:表示多行。</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-keyword">var</span> expression = <span class="hljs-regexp">/ pattern /</span> flags
</div></code></pre>

<ol start="2"><li rel="2"><p>pattern 中使用的所有元字符都必须转义。 <br>
() [] {} \ ^ $ | ? * + .  </p></li>
<li rel="3"><p>RegExp构造函数 <br>
pattern1和pattern2完全等价，但由于RegExp的参数是字符串，所以在使用元字符时都必须双重转义。</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-keyword">var</span> pattern1=<span class="hljs-regexp">/ [bc]at /i</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> pattern2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"[bc]at"</span>,<span class="hljs-string">"i"</span>);
</div><div class="hljs-line">    <span class="hljs-comment">//匹配 [bc]at ,字面量是 / \[bc\]at /</span>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> pattern3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"\\[bc\\]at"</span>,<span class="hljs-string">"i"</span>);
</div></code></pre>

<ol start="4"><li rel="4"><p>RegExp的实例属性 <br>
global：布尔值，表示是否设置了g标识，相似的还有ignoreCase、multiline，分别表示i、m标识。 <br>
source：正则表达式的字符串表示 <br>
lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</p></li>
<li rel="5"><p>RegExp实例方法</p>

<ol>
<li rel="1"><p>exec( ) ,参数是一个要匹配模式的字符串，没有匹配项时返回null，有匹配项时返回一个数组，第一项是与整个模式匹配的字符串， 第二项是与 RegExp的实例 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。  <br>
对于exec( ) 方法而言，即是在模式中设置全局标识（g），它每次也只会返回一个匹配项。 <br>
在不设置全局标志的情况下，在同一个字符串上多次调用exec( ) 将始终返回第一个匹配项的信息，而在设置全局标识的情况下，每次调用exec( ) 则都会在字符串中继续查找新匹配项。</p></li>
<li rel="2"><p>test( ) ，接收一个字符串参数，在模式与参数匹配的情况下返回true；否则返回false。</p></li></ol></li>
<li rel="6"><p>RegExp构造函数属性 <br>
RegExp构造函数包含一些属性（你可以认为这是RegExp类型的 “静态属性”）。这些属性适用与作用域中的所有正则表达式。这些属性分别有自己的长属性名和短属性名。</p></li>
</ol>

<table><tbody><tr style="font-weight:bold">  <td align="center">长属性名</td>  <td align="center">短属性名</td>  <td align="center">说明</td></tr><tr>  <td align="center">input</td>  <td align="center">$_</td>  <td align="center">最近一次要匹配的字符串</td></tr><tr>  <td align="center">lastMatch</td>  <td align="center">$&amp;</td>  <td align="center">最近一次匹配项</td></tr><tr>  <td align="center">lastParen</td>  <td align="center">$+</td>  <td align="center">最近一次匹配的捕获组</td></tr><tr>  <td align="center">leftContext</td>  <td align="center">$`</td>  <td align="center">input字符串中lastMatch之前的文本</td></tr><tr>  <td align="center">multiline</td>  <td align="center">$*</td>  <td align="center">布尔值，表示是否所有的表达式都使用多行模式</td></tr><tr>  <td align="center">rightContext</td>  <td align="center">$’</td>  <td align="center">input字符串中lastMatch之后的文本</td></tr></tbody></table>



<h2 id="function-类型">Function 类型</h2>

<ol><li rel="1"><p>函数实际上是一个对象。（<strong>函数是对象，函数名是指针</strong>）</p></li>
<li rel="2"><p>函数的三种语法</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-comment">//函数声明语法</span>
</div><div class="hljs-line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1,num2</span>)</span>{
</div><div class="hljs-line">    <span class="hljs-keyword">return</span> num1+num2;
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-comment">//函数表达式</span>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> sum=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1,num2</span>)</span>{
</div><div class="hljs-line">    <span class="hljs-keyword">return</span> num1+num2;
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-comment">//Function构造函数</span>
</div><div class="hljs-line">    <span class="hljs-comment">//不推荐这种写法，不过它可以帮你理解 “函数是对象，函数名是指针” 的概念。</span>
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> sum=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">"num1"</span>,<span class="hljs-string">"num2"</span>,<span class="hljs-string">"return num1+num2"</span>);
</div><div class="hljs-line"><wbr>
</div></code></pre>

<ol start="3"><li rel="3"><p>每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。</p></li>
<li rel="4"><p>函数名实际上是一个指向函数对象的指针。</p></li>
<li rel="5"><p>JavaScript 没有重载。</p></li>
<li rel="6"><p><strong>函数声明在代码执行的顺序中优于函数表达式</strong>，原因是在代码开始执行之前，解析器就已经通过一个名为函数声明提升的过程，读取并将声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript 引擎也能把声明函数提示到顶部。</p></li>
<li rel="7"><p>解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码之前可以访问；至于函数表达式，则必须等到解析器到它所在的代码行，才会真正被解释执行。</p></li>
</ol>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-comment">//函数声明,可以执行</span>
</div><div class="hljs-line">            alert(sum(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));
</div><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1,num2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> num1+num2;
</div><div class="hljs-line">            }
</div><div class="hljs-line">            <span class="hljs-comment">//函数表达式，报错</span>
</div><div class="hljs-line">            alert(sum(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> sum=<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num1,num2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> num1+num2;
</div><div class="hljs-line">            }
</div></code></pre>

<ol start="8"><li rel="8"><p>要访问函数的指针而不执行函数的话，必须去掉函数名后面那对圆括号。</p></li>
<li rel="9"><p>因为函数名本身就是变量，所以函数可以作为值来使用。第一你可以像传递参数一样把一个函数传递给另一个函数，第二你可以将函数作为另一个函数的结果返回。</p></li>
<li rel="10"><p>函数内部的属性</p>

<ol>
<li rel="1"><p>arguments.callee 该属性是一个指针，指向 拥有arguments对象的函数。（现在已逐渐淘汰，尽量不要用）</p></li>
<li rel="2"><p>arguments 是一个类数组的对象。</p></li>
<li rel="3"><p>this ，this引用的是函数执行的环境对象，当在网页的全局作用域中调用函数时this对象引用的就是window。</p></li>
<li rel="4"><p>caller ，这个属性中保存着调用当前函数的引用，如果是在全局作用域中调用当前函数，它的值为null。另外也可以通过 arguments.callee.caller 来访问该属性。</p></li></ol></li>
<li rel="11"><p>函数属性和方法</p>

<ol>
<li rel="1"><p>function.object.length，表示函数希望接收的命名参数的个数。</p></li>
<li rel="2"><p>prototype ，引用类型的原型，用以保存引用类型实例方法。（之后的JavaScript的面向对象会重点提到，这里不做过多介绍。）</p></li>
<li rel="3"><p>apply( ) 和 call( ) 的用途都是在特定的作用域中调用函数，也可以理解为扩充函数作用域的方法。它们的区别只是在参数的传递上。</p></li>
<li rel="4"><p>bind( ) ,这个方法会创建一个函数的实例，其this值会被绑定到传给bind( )函数的值。</p></li></ol></li>
</ol>



<h2 id="基本包装类型">基本包装类型</h2>

<ol><li rel="1"><p>基本包装类型即Boolean、Number和String。可以理解为Object 对布尔值、数值、字符串的包装类型。</p></li>
<li rel="2"><p>Number 的方法</p>

<ol>
<li rel="1"><p>Number.toFixed( ) ，按照指定的小数位返回数值的字符串表示，适用于处理货币值。</p></li>
<li rel="2"><p>Number.toExponetial( ) ，以指数表示法返回数值的字符串形式。</p></li>
<li rel="3"><p>Number.toPrecision( ) ，根据表示数值所有数字的位数的参数，来返回不同的数值表示法。</p></li></ol></li>
<li rel="3"><p>String 类型</p>

<ol>
<li rel="1"><p>String.length ，返回字符串的字符数。</p></li>
<li rel="2"><p>String.charAt( ) ，参数是字符的length值，返回指定位置的字符。（实际上是字符串，因为JS没字符类型）</p></li>
<li rel="3"><p>String.charCodeAt( ) ，参数是字符的length值，返回指定位置的字符编码。</p></li>
<li rel="4"><p>String.concat( ) ，连接两个字符串。</p></li>
<li rel="5"><p>slicce( )、substr( )、substring( ) ，基于子字符串创建新的字符串的方法。</p></li>
<li rel="6"><p>indexOf( )、lastIndexOf( ) ，搜索给定的子字符串，返回子字符串的位置，一个从前往后，一个从后往前。</p></li>
<li rel="7"><p>trim( ) ，创建一个字符串的副本，删除前置和后缀的所有空格.</p></li>
<li rel="8"><p>字符串大小写装换方法，toLowerCase( ) 、toLocalLowerCase( ) 、toUpperCase( ) 、toLocalUpperCase( ) 。</p></li>
<li rel="9"><p>match( )，参数是一个正则表达式或RegExp对象，返回匹配模式的数组。</p></li>
<li rel="10"><p>search( )，参数是一个正则表达式或RegExp对象，返回第一个匹配项的索引，没找到返回-1.</p></li>
<li rel="11"><p>replace( ),参数是第一个RegExp对象或是一个字符串（非正则表达式），第二个是用以替换的字符串或者是一个函数。</p></li>
<li rel="12"><p>split( )，基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组里。第一个参数是分隔符，也可以是一个RegExp对象，第二个参数是数组的长度。</p></li>
<li rel="13"><p>String.localeCompare(str )，用于比较两个字符串，返回数字-1，0，1 。零是两个字符串相等，正一和负一表示参数的首字母在字符串之前或之后。这个方法不区分大小写。  </p></li></ol></li>
</ol>

<p>2019.12.20</p></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/12/16/红宝书阅读笔记ch5-2/" data-id="ck67be8hm000bacva6uc53c7x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch5-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/29/红宝书阅读笔记ch5-1/" class="article-date">
  <time datetime="2019-11-29T13:35:02.550Z" itemprop="datePublished">2019-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch5-1</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch5-1">红宝书阅读笔记ch5-1</h1>

<p>Object类型和Array类型</p>



<h2 id="引用类型">引用类型</h2>

<ul><li><p>引用类型的值（对象）是引用类型的实例。可以理解成Java里的对象和类的关系。</p></li>
<li><p>引用类型是一种数据结构，用于将数据和功能组织在一起。</p></li>
</ul>



<h4 id="object类型">Object类型</h4>

<ul><li><p>创建Object的两种方式；</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//第一种方式 new 操作符后跟Object构造函数</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> person =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();
</div><div class="hljs-line">person.name=<span class="hljs-string">"1n40"</span>;
</div><div class="hljs-line">person.age=<span class="hljs-number">21</span>;
</div><div class="hljs-line"><span class="hljs-comment">//第二种方式 对象字面量表示法</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> person={
</div><div class="hljs-line"><span class="hljs-attr">name</span>:<span class="hljs-string">"1n40"</span>,
</div><div class="hljs-line"><span class="hljs-attr">age</span>:<span class="hljs-number">21</span>
</div><div class="hljs-line">};
</div><div class="hljs-line"><span class="hljs-comment">//使用对象字面量语法时，属性名也可以使用字符串</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> person={
</div><div class="hljs-line"><span class="hljs-string">"name"</span>:<span class="hljs-string">"1n40"</span>,
</div><div class="hljs-line"><span class="hljs-string">"age"</span>:<span class="hljs-number">21</span>,
</div><div class="hljs-line"><span class="hljs-number">5</span>:<span class="hljs-literal">true</span>
</div><div class="hljs-line">};
</div><div class="hljs-line"><span class="hljs-comment">//</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> person={};  <span class="hljs-comment">// 与 new Object()相同</span>
</div><div class="hljs-line">person.name=<span class="hljs-string">"1n40"</span>;
</div><div class="hljs-line">person.age=<span class="hljs-number">21</span>;
</div></code></pre>

<ul><li><p>对象字面量也是向函数传递大量可选参数的首选方式；</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayInfo</span>(<span class="hljs-params">args</span>) </span>{
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> output = <span class="hljs-string">""</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.name == <span class="hljs-string">"string"</span>){
</div><div class="hljs-line">                output += <span class="hljs-string">"Name: "</span> + args.name + <span class="hljs-string">"\n"</span>;
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.age == <span class="hljs-string">"number"</span>) {
</div><div class="hljs-line">                output += <span class="hljs-string">"Age: "</span> + args.age + <span class="hljs-string">"\n"</span>;
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            alert(output);
</div><div class="hljs-line">        }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        displayInfo({ 
</div><div class="hljs-line">            <span class="hljs-attr">name</span>: <span class="hljs-string">"Nicholas"</span>, 
</div><div class="hljs-line">            <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>
</div><div class="hljs-line">        });
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        displayInfo({
</div><div class="hljs-line">            <span class="hljs-attr">name</span>: <span class="hljs-string">"Greg"</span>
</div><div class="hljs-line">        });
</div></code></pre>

<ul><li><p>访问对象属性的两种方法：</p>

<ul>
<li><p>点表示法；</p></li>
<li><p>方括号表示法。</p></li>
<li><p>一般来说，访问对象属性时使用的都是点表示法,因为点表示法比方括号表示法更加简洁和方便,假如属性名中包含导致语法错误的字符，或者属性名使用了关键字和保留字，这时候使用方括号表示法更佳。</p></li>
<li><p>通常我们一般推荐用点表示法。</p></li>
<li><p>在通过对象字面量定义对象时，实际上不会调用Object 构造函数。</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//功能上两种方法没有任何区别</span>
</div><div class="hljs-line">alert(person[<span class="hljs-string">"name"</span>]);
</div><div class="hljs-line">alert(person.name);
</div><div class="hljs-line"><span class="hljs-comment">//方括号表示法的优点是可以通过变量来访问属性,和访问一些有特殊字符的变量名</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> propertyName=<span class="hljs-string">"name"</span>;
</div><div class="hljs-line">alert(person[propertyName]); <span class="hljs-comment">// 值是 “name”</span>
</div><div class="hljs-line"><span class="hljs-comment">//属性名包含空格，不能点出来</span>
</div><div class="hljs-line">person[<span class="hljs-string">"first name"</span>]=<span class="hljs-string">"1n40"</span>;
</div></code></pre>



<h4 id="array类型">Array类型</h4>

<ul><li><p>Array类型的三个特点：</p>

<ul>
<li><p>有序列表；</p></li>
<li><p>数组的每一项可以保存任何类型的数据；</p></li>
<li><p>数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p></li></ul></li>
<li><p>创建数组的基本方式有两种</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//第一种使用Array构造函数</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">20</span>);
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>);
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=<span class="hljs-built_in">Array</span>();  <span class="hljs-comment">//可以省略new关键字，结果相同</span>
</div><div class="hljs-line"><span class="hljs-comment">//第二种方式是使用数组字面量表示法</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];  
</div><div class="hljs-line"><span class="hljs-keyword">var</span> names=[];
</div><div class="hljs-line"><span class="hljs-keyword">var</span> values=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,];  <span class="hljs-comment">//错误示范！这样会创建一个包含2或3项的数组（视浏览器而定）</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> options=[,,,,,];<span class="hljs-comment">//错误示范！这样会创建一个包含5或6项的数组（视浏览器而定）</span>
</div></code></pre>

<ul><li><p>给构造函数传递一个值也可以创建数组，如果传递的是数值，则按照数值创建指定项数的数组，而如果传递的是非数值的参数，则创建一个包含那个值的只有一项的数组。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);
</div><div class="hljs-line"><span class="hljs-keyword">var</span> name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">"Grey"</span>);
</div></code></pre>

<ul><li><p>读取和设置数组时，要使用方括号并提供相应值基于0的数字索引；</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];
</div><div class="hljs-line">alert(colors[<span class="hljs-number">0</span>]);                   <span class="hljs-comment">//显示第一项 red </span>
</div><div class="hljs-line">colors[<span class="hljs-number">2</span>]=<span class="hljs-string">"black"</span>;                  <span class="hljs-comment">//修改第三项</span>
</div><div class="hljs-line">colors[<span class="hljs-number">3</span>]=<span class="hljs-string">"brown"</span>;                  <span class="hljs-comment">//新增第四项</span>
</div></code></pre>

<ul><li><p>数组的项数保存在length属性中，这个属性始终返回0或更大的数字。</p></li>
<li><p>数组的length属性不只是只读的，通过设置这个属性可以从数组的末尾移除项或者向数组中添加新项。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//移除最后一项</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];
</div><div class="hljs-line">colors.length=<span class="hljs-number">2</span>;                    <span class="hljs-comment">//移除数组的第三项</span>
</div><div class="hljs-line">alert(colors[<span class="hljs-number">2</span>]);                   <span class="hljs-comment">//undefined</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//在数组的末尾添加一项 undefined</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];
</div><div class="hljs-line">colors.length=<span class="hljs-number">4</span>;    
</div><div class="hljs-line">alert(colors[<span class="hljs-number">3</span>]);                   <span class="hljs-comment">//undefined</span>
</div><div class="hljs-line"><span class="hljs-comment">//在数组的末尾添加两项 属性值</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];
</div><div class="hljs-line">colors[colors.length]=<span class="hljs-string">"black"</span>;      <span class="hljs-comment">//（在位置3）添加一种颜色</span>
</div><div class="hljs-line">colors[colors.length]=<span class="hljs-string">"brown"</span>;      <span class="hljs-comment">//（在位置4）添加一种颜色</span>
</div></code></pre>

<ul><li><p>检测数组的两个方法；</p>

<ul>
<li><p>instanceof 操作符，适用用单个网页或单个全局作用域</p></li>
<li><p>Array.isArray() 方法。适用用网页中包含多个框架，存在着两个及以上不同的全局作用域。</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//instanceof </span>
</div><div class="hljs-line"><span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>){
</div><div class="hljs-line">    <span class="hljs-comment">//对数组执行某些操作</span>
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">//Array.isArray() </span>
</div><div class="hljs-line"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(value)){
</div><div class="hljs-line">    <span class="hljs-comment">//对数组执行某些操作</span>
</div><div class="hljs-line">}
</div></code></pre>

<ul><li><p>转换方法，所有对象都有toLocaleString()、toString()、和valueOf()方法。其中，调用valueOf()返回的是调用这个函数的变量本身，是数组类型的就返回这个数组的副本，是字符串返回的也是这个字符串的副本。toString()返回的是这个变量的字符串表示。而toLocaleString()就比较复杂，locale直译是地区的，通常情况下toLocaleString()返回的和toString()返回的相同，但对于Number、Date、Array而言会根据toLocaleString()的参数来返回不同格式的字符串。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-keyword">var</span> array1 = [<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'21 Dec 1997 14:12:00 UTC'</span>)];
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> localeString = array1.toLocaleString(<span class="hljs-string">'en'</span>, {
</div><div class="hljs-line">                <span class="hljs-attr">timeZone</span>: <span class="hljs-string">"UTC"</span>
</div><div class="hljs-line">            });<span class="hljs-comment">//可以cn表示中国的时间格式，en表示英国的时间格式</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-built_in">console</span>.log(localeString);
</div><div class="hljs-line">            <span class="hljs-comment">// expected output: "1,a,12/21/1997, 2:12:00 PM",</span>
</div><div class="hljs-line">            <span class="hljs-comment">// This assumes "en" locale and UTC timezone - your results may vary</span>
</div></code></pre>

<ul><li><p>转换方法，还可以通过Array.join()来替代Array.toString().</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> colors=[<span class="hljs-string">"red"</span>,<span class="hljs-string">"blue"</span>,<span class="hljs-string">"green"</span>];
</div><div class="hljs-line">colors.join(<span class="hljs-string">","</span>);
</div><div class="hljs-line">colors.join(<span class="hljs-string">"||"</span>);
</div></code></pre>

<ul><li><p>转换方法，如果数组中的某一项的值是null或者undefined，那么该值在 join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。</p></li>
<li><p>数组的常用方法：</p>

<ul>
<li><p>push() 方法接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改过后的数组长度。</p></li>
<li><p>pop() 方法从数组末尾移除最后一项，减少数组的length值，并返回移除的项。</p></li>
<li><p>shift() 方法移除数组中的第一项并返回该项，同时将数组的长度减1。</p></li>
<li><p>unshift() 方法在数组的前端添加任意项，并返回新数组的长度。</p></li>
<li><p>reverse() 方法会反转数组项的顺序，并返回经过排序的数组。</p></li>
<li><p>sort() 方法按升序列排列数组，并返回经过排序后的数组，sort() 方法比较的是通过数组项的toString()转型方法得到的字符串，所以通常我们让sort() 接受一个比较函数来进行排序。</p></li>
<li><p>concat() 方法会先创建当前数组的一个副本，然后将接受的参数添加到这个副本的末尾，最后返回新构建的数组。</p></li>
<li><p>slice() 方法能够基于当前数组的一个或多个项创建一个新数组，一个参数的情况下slice() 方法返回从该参数指定的位置开始到数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项—但不包括结束位置的项。slice() 方法不会影响原始数组。</p></li>
<li><p>splice() 方法的主要用途是向数组的中部插入项，使用这种方法的方式有三种，删除、插入、替换。splice() 方法始终返回从原始数组中删除的项，如果没有删除任何向则返回一个空数组。</p></li>
<li><p>indexOf()和lastIndexOf() 方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中indexOf() 方法从前向后找，lastIndexOf() 方法从后往前找。这两个方法返回的是要查找项的在数组中的位置，没有找到则返回 -1 。</p></li></ul></li>
<li><p>栈方法，栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构，通过push()和pop() 方法可以模仿出栈的行为。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> count=colors.push(<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>);
</div><div class="hljs-line">            alert(count);                       <span class="hljs-comment">// 2</span>
</div><div class="hljs-line">            count=colors.push(<span class="hljs-string">"black"</span>);
</div><div class="hljs-line">            alert(count);                       <span class="hljs-comment">//3</span>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> item=colors.pop();
</div><div class="hljs-line">            alert(item);                        <span class="hljs-comment">//black</span>
</div><div class="hljs-line">            alert(colors.length);               <span class="hljs-comment">//2</span>
</div></code></pre>

<ul><li><p>队列，通过push() 和shift() 方法来模仿队列（先进先出）的行为。通过unshift()方法还可以从相反的方向来模仿队列。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-comment">//push()和shift()</span>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> colors=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> count=colors.push(<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>);
</div><div class="hljs-line">            alert(count);<span class="hljs-comment">//2</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            count=colors.push(<span class="hljs-string">"black"</span>);
</div><div class="hljs-line">            alert(count);<span class="hljs-comment">//3</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> item=colors.shift();
</div><div class="hljs-line">            alert(item);            <span class="hljs-comment">//red</span>
</div><div class="hljs-line">            alert(colors.length);   <span class="hljs-comment">//2</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">//push()和unshift()</span>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> count=colors.unshift(<span class="hljs-string">"red"</span>,<span class="hljs-string">"green"</span>);  <span class="hljs-comment">//red,green</span>
</div><div class="hljs-line">            alert(count);       <span class="hljs-comment">//2</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            count=colors.unshift(<span class="hljs-string">"black"</span>);            <span class="hljs-comment">//black,red,green</span>
</div><div class="hljs-line">            alert(count);       <span class="hljs-comment">//3</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> item=colors.pop();                    <span class="hljs-comment">//green</span>
</div><div class="hljs-line">            alert(item)        
</div><div class="hljs-line">            alert(colors.length);                     <span class="hljs-comment">//2</span>
</div></code></pre>

<ul><li><p>排序，直接用来重新排序数组的方法有两个，reverse()方法是直接将数组反转项的顺序，sort()方法默认是通过每个数组项的toString()方法，然后比较得到的字符串，以确定如何排序，即便数组项是数字也是这样，大多数情况下得到的结果都不理想。通常情况我们会给sort()方法一个比较函数作为参数，来进行排序。</p></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-comment">//比较函数</span>
</div><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comare</span>(<span class="hljs-params">value1,value2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">if</span>(value1 &lt; value2){
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value1 &gt; value2){
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div><div class="hljs-line">                }
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> values=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>];
</div><div class="hljs-line">            values.sort(comare);
</div><div class="hljs-line">            alert(values);
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-comment">//修改比较函数的返回结果就可以得到降序</span>
</div><div class="hljs-line">                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comare</span>(<span class="hljs-params">value1,value2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">if</span>(value1 &lt; value2){
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">//修改这里</span>
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value1 &gt; value2){
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//还有这里</span>
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span>{
</div><div class="hljs-line">                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</div><div class="hljs-line">                }
</div><div class="hljs-line">            }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> values=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>];
</div><div class="hljs-line">            values.sort(comare);
</div><div class="hljs-line">            alert(values);
</div><div class="hljs-line">            <span class="hljs-comment">//对于数值或者valueOf方法会返回数值类型的对象类型，比较函数会更加简单</span>
</div><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comare</span>(<span class="hljs-params">value1,value2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> value2-value1;<span class="hljs-comment">//这是降序</span>
</div><div class="hljs-line">                <span class="hljs-comment">//return value1-value2; 这是升序</span>
</div><div class="hljs-line">            }
</div></code></pre>

<ul><li><p>Array的迭代方法： <br>
ECMAScript5 为数组定义了五个迭代方法，每个方法都要接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象—影响this的值。传入这些迭代方法的函数都会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。</p>

<ul>
<li><p>every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</p></li>
<li><p>filter() ：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p></li>
<li><p>forEach() : 对数组中的每一项运行给定函数，这个方法没有返回值。</p></li>
<li><p>map() ：对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组。</p></li>
<li><p>some() :对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</p></li>
<li><p>以上方法都不会修改数组中包含的值。</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-keyword">var</span> numbers=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> everyResult=numbers.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item,index,array</span>)</span>{
</div><div class="hljs-line">        <span class="hljs-keyword">return</span> (item&gt;<span class="hljs-number">2</span>);
</div><div class="hljs-line">    });
</div><div class="hljs-line">    alert(everyResult);
</div></code></pre>

<ul><li><p>Array的归并方法：</p>

<ul>
<li><p>reduce() </p></li>
<li><p>reduceRight()</p></li>
<li><p>以上两个方法都是归并函数，一个从左到右另一个从右到左，这两个方法都接收两个参数：一个在每一项上调用的函数和（可选）作为归并的基础值。传给归并方法的函数接收4个函数：前一个值、当前值、项的索引和数组对象。</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-light"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-keyword">var</span> values=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]; 
</div><div class="hljs-line">            <span class="hljs-keyword">var</span> sum=values.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prev,cur,index,array</span>) </span>{
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> prev+cur;
</div><div class="hljs-line">            },<span class="hljs-number">1</span>);
</div><div class="hljs-line">            alert(sum);<span class="hljs-comment">//16</span>
</div></code></pre>

<p>2019.11.29  </p></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/11/29/红宝书阅读笔记ch5-1/" data-id="ck67be8he000aacvavu1rbnjy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/07/红宝书阅读笔记ch4/" class="article-date">
  <time datetime="2019-11-07T07:04:15.065Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch4</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch4">红宝书阅读笔记ch4</h1>

<h3 id="基本类型和引用类型的值">基本类型和引用类型的值</h3>

<ul><li><p>基本类型值指的是简单的数据段，而引用类型值可能是由多个值构成的对象。</p></li>
<li><p>基本类型值是按值访问的，因为是可以操作再变量中实际的值，引用类型的值是保存内存中的对象，JavaScript不允许直接访问内存中的位置，在操作对象时，实际上是在操作对象的引用而不是实际的对象，因此，引用类型的值是按引用访问的。</p></li>
<li><p>字符串是基本类型的，而不是引用类型的。</p></li>
<li><p>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。对于基本类型的值不能添加属性，尽管这样做不会导致任何错误。</p></li>
<li><p>对于复制变量值，基本类型的值复制的是值，而引用类型复制的是这个值的指针，两个变量引用的是同一个对象，改变其中一个的值，就会影响另一个值。</p></li>
<li><p>ECMAScript中所有的函数的参数都是按值传递的。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。对于访问变量有按值和引用两种方式，而参数只能按值传递，这一点可以归功于函数的执行环境和作用域。</p></li>
<li><p>typeOf 操作符用于检测基本数据类型，而instanceof 操作符可以检测某个值是不是对象，是什么类型的对象。</p></li>
</ul>

<h3 id="执行环境和作用域">执行环境和作用域</h3>

<ul><li><p>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是Window对象。</p></li>
<li><p>作用域链，是代码在一个环境中执行时为变量对象创建的，作用是保证对执行环境有权访问的所有变量和函数的有序访问，即里层的执行环境可以访问外部执行环境的变量和函数，而外部的执行环境无权访问里层的执行环境。全局执行环境是作用域链的最后一个对象。当前环境是作用域的前端。</p></li>
<li><p>函数参数也被当做变量对待，访问规则和执行环境中的其他变量相同（即arguments数组）。</p></li>
<li><p>延长作用域链的方法有两个:</p>

<ul>
<li><p>try-catch语句的catch块；</p></li>
<li><p>with语句。</p></li></ul></li>
<li><p>上述的两个语句都会在作用域的前端添加一个变量对象。对with语句来说，会将指定对象添加到作用域中。对catch语句来说，会创建一个新的变量对象，其中包含的是抛出的错误对象的声明。</p></li>
<li><p>JavaScript 没有块即作用域，在其他类C的语言中，有花括号封闭的的代码都有自己的作用域。（如if、for等语句）在这些有花括号的语句中创建的变量会在语句结束后添加到当前的执行环境中，如for循环中创建的i 会在循环结束后添加到当前的执行环境中，这一点需要注意。</p></li>
<li><p>使用var声明的变量会自动被添加到最近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会被添加到全局环境中。</p></li>
<li><p>标识符，就是声明变量的变量名，在某个环境中为了读取或写入而引用一个标识符是，必须通过逐级搜索标识符才能确定标识符实际代表什么，如果在局部环境中没有找到该变量名则继续沿用作用链向上搜索，知道全局环境，如果在全局环境中就证明没有申声明这个该变量。如果在某个局部环境中找到了，就不继续向上搜索了。也可以认为在局部环境中存在着同名的标识符，就不会使用父环境中的标识符。</p></li>
</ul>

<h3 id="垃圾收集">垃圾收集</h3>

<ul><li><p>垃圾收集有两种方式，标识清除和引用记数两种方式，现常用的是标识清除。</p></li>
</ul></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/11/07/红宝书阅读笔记ch4/" data-id="ck67be8hc0009acvaat61zd17" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch3-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/06/红宝书阅读笔记ch3-3/" class="article-date">
  <time datetime="2019-11-06T12:44:00.969Z" itemprop="datePublished">2019-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch3-3</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style></style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch3-3">红宝书阅读笔记ch3-3</h1>



<h3 id="语句">语句</h3>

<p>由于笔者对if、do-while、while、for、break、continue、switch这些语句已经很熟悉了，这里就不在这里花跟更多的功夫去记了，如果有不了解这些流程控制语句的读者可前往：<a href="https://www.w3school.com.cn" target="_blank">w3schoo</a>、<a href="http://www.runoob.com" target="_blank">菜鸟教程网</a> 了解相应的语句。 <br>
接下来笔者会记一下以往不熟悉的语句，如label、with等。</p>

<ul><li><p>for-in语句，是一种精准的迭代语句，可以用来枚举对象的属性。 <br>
语法： <br>
for (property in expression) statement <br>
示例：</p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> proName <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) {
</div><div class="hljs-line">        <span class="hljs-built_in">document</span>.writeln(proName);
</div><div class="hljs-line">    }
</div></code></pre>

<p>注意：由于ECMAScript对象的属性没有顺序，因此对于for-in语句循环输出的语句是不可预测的，虽然每个属性都会返回一次，但返回的先后顺序因浏览器而异。如果迭代对象的变量值为null或undefined，for-in语句会抛出错误，在 ES5以后，对于这种情况不再抛出错误而是不再执行循环体。为了保证兼容性，建议在使用for-in语句以前，先检测该对象的值是不是null或undefined。  </p>

<ul><li><p>使用label语句可以在代码中添加标签，以便将来使用。 <br>
语法： <br>
label: statement <br>
举例:  </p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>;
</div><div class="hljs-line">outermost:
</div><div class="hljs-line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>;i++){
</div><div class="hljs-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span>; j++){
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span> &amp;&amp; j==<span class="hljs-number">5</span>){
</div><div class="hljs-line">            <span class="hljs-keyword">break</span> outermost;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        num++;  
</div><div class="hljs-line">    }
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-built_in">console</span>.log(num);       <span class="hljs-comment">//55</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> num=<span class="hljs-number">0</span>;
</div><div class="hljs-line">outermost:
</div><div class="hljs-line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>;i++){
</div><div class="hljs-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">10</span>; j++){
</div><div class="hljs-line">        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span> &amp;&amp; j==<span class="hljs-number">5</span>){
</div><div class="hljs-line">            <span class="hljs-keyword">continue</span> outermost;
</div><div class="hljs-line">        }
</div><div class="hljs-line">        num++;  
</div><div class="hljs-line">    }
</div><div class="hljs-line">}
</div><div class="hljs-line"><span class="hljs-built_in">console</span>.log(num);       <span class="hljs-comment">//95</span>
</div></code></pre>

<p>标签由break或continue语句引用。加标签的语句一般都是要与for语句等循环语句使用。</p>

<ul><li><p>with语句的作用是将代码的作用域设置到一个特定的对象中。 <br>
语法： <br>
with (expression) statement ; <br>
定义with语句的主要目的是为了简化编写多次编写同一个对象的工作，举例：  </p></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> qs=location.search.substring(<span class="hljs-number">1</span>);
</div><div class="hljs-line"><span class="hljs-keyword">var</span> hostName=location.hostname;
</div><div class="hljs-line"><span class="hljs-keyword">var</span> url=location.href;
</div><div class="hljs-line"><span class="hljs-comment">//上面的代码都包含location对象，使用with语句改写如下：</span>
</div><div class="hljs-line"><span class="hljs-keyword">with</span> (location){
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> qs=search.substring();
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> hostName=hostname;
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> url=href;
</div><div class="hljs-line">    }
</div></code></pre>

<blockquote>
  <p>注意：大量使用with语句会导致性能下降，同时也给代码调试带来不便，因此在开发大型应用程序时，不建议使用with语句。同时严格模式下不允许使用with语句。</p>
</blockquote>



<h3 id="函数">函数</h3>

<ol><li rel="1"><p>通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。</p></li>
<li rel="2"><p>要么让函数始终都返回一个值，要么永远都不要返回值。</p></li>
<li rel="3"><p>ECMAScript中参数在内部是用一个数组来表示，在函数体内通过arguments对象来访问这个参数数组，从而获取传给函数的每一个参数。</p></li>
</ol>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">    alert(<span class="hljs-string">"Hello "</span>+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-string">","</span>+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
</div><div class="hljs-line">    alert(<span class="hljs-built_in">arguments</span>.length); <span class="hljs-comment">//参数数组的长度 </span>
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAdd</span>(<span class="hljs-params"></span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length==<span class="hljs-number">1</span>){
</div><div class="hljs-line">                    alert(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-number">10</span>);
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length==<span class="hljs-number">2</span>){
</div><div class="hljs-line">                    alert(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
</div><div class="hljs-line">                }
</div><div class="hljs-line">            }
</div><div class="hljs-line">            doAdd(<span class="hljs-number">10</span>); <span class="hljs-comment">//20</span>
</div><div class="hljs-line">            doAdd(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>); <span class="hljs-comment">//40</span>
</div><div class="hljs-line">            <span class="hljs-comment">//arguments对象可以和命名参数一起使用</span>
</div><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAdd</span>(<span class="hljs-params">num1,num2</span>)</span>{
</div><div class="hljs-line">                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length==<span class="hljs-number">1</span>){
</div><div class="hljs-line">                    alert(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-number">10</span>);
</div><div class="hljs-line">                }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length==<span class="hljs-number">2</span>){
</div><div class="hljs-line">                    alert(num1+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);
</div><div class="hljs-line">                }
</div><div class="hljs-line">            }
</div><div class="hljs-line">            doAdd(<span class="hljs-number">10</span>);
</div><div class="hljs-line">            doAdd(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);
</div></code></pre>

<ol start="4"><li rel="4"><p>ECMAScript因为没有函数签名所以做不到真正的重载，如果在ECMAScript定义了两个名字相同的函数，则改名字属于后定义的函数。</p></li>
<li rel="5"><p>通过检查传入函数中参数的类型和数量并做出不同的反应可以模仿方法的重载。</p></li>
</ol></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/11/06/红宝书阅读笔记ch3-3/" data-id="ck67be8ha0008acvam7djzkdh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-freeCodeCamp 前端开发课程 220（Profile Lookup）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/24/freeCodeCamp 前端开发课程 220（Profile Lookup）/" class="article-date">
  <time datetime="2019-10-24T12:44:24.512Z" itemprop="datePublished">2019-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>freeCodeCamp 前端开发课程 220（Profile Lookup）</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style></style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h2 id="freecodecamp-前端开发课程-220profile-lookup">freeCodeCamp 前端开发课程 220（Profile Lookup）</h2>

<p>今天在FCC上遇到了一题较难的题目记录下来，以备后用。</p>

<p>题目： <br>
我们有一个对象数组，里面存储着通讯录。</p>

<p>函数 lookUp 有两个预定义参数：firstName值和prop属性 。</p>

<p>函数将会检查通讯录中是否存在一个与传入的 firstName 相同的联系人。如果存在，那么还需要检查对应的联系人中是否存在 prop属性。</p>

<p>如果它们都存在，函数返回prop属性对应的值。</p>

<p>如果firstName 值不存在，返回 “No such contact”。</p>

<p>如果prop 属性不存在，返回 “No such property”。</p>

<hr>

<p>源码:</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-comment">//初始化变量</span>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> contacts = [
</div><div class="hljs-line">    {
</div><div class="hljs-line">        <span class="hljs-string">"firstName"</span>: <span class="hljs-string">"Akira"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"lastName"</span>: <span class="hljs-string">"Laine"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"number"</span>: <span class="hljs-string">"0543236543"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"likes"</span>: [<span class="hljs-string">"Pizza"</span>, <span class="hljs-string">"Coding"</span>, <span class="hljs-string">"Brownie Points"</span>]
</div><div class="hljs-line">    },
</div><div class="hljs-line">    {
</div><div class="hljs-line">        <span class="hljs-string">"firstName"</span>: <span class="hljs-string">"Harry"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"lastName"</span>: <span class="hljs-string">"Potter"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"number"</span>: <span class="hljs-string">"0994372684"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"likes"</span>: [<span class="hljs-string">"Hogwarts"</span>, <span class="hljs-string">"Magic"</span>, <span class="hljs-string">"Hagrid"</span>]
</div><div class="hljs-line">    },
</div><div class="hljs-line">    {
</div><div class="hljs-line">        <span class="hljs-string">"firstName"</span>: <span class="hljs-string">"Sherlock"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"lastName"</span>: <span class="hljs-string">"Holmes"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"number"</span>: <span class="hljs-string">"0487345643"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"likes"</span>: [<span class="hljs-string">"Intriguing Cases"</span>, <span class="hljs-string">"Violin"</span>]
</div><div class="hljs-line">    },
</div><div class="hljs-line">    {
</div><div class="hljs-line">        <span class="hljs-string">"firstName"</span>: <span class="hljs-string">"Kristian"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"lastName"</span>: <span class="hljs-string">"Vos"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"number"</span>: <span class="hljs-string">"unknown"</span>,
</div><div class="hljs-line">        <span class="hljs-string">"likes"</span>: [<span class="hljs-string">"Javascript"</span>, <span class="hljs-string">"Gaming"</span>, <span class="hljs-string">"Foxes"</span>]
</div><div class="hljs-line">    }
</div><div class="hljs-line">];
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookUp</span>(<span class="hljs-params">firstName, prop</span>)</span>{
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以下</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以上</span>
</div><div class="hljs-line">}
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 你可以修改这一行来测试你的代码</span>
</div><div class="hljs-line">lookUp(<span class="hljs-string">"Akira"</span>, <span class="hljs-string">"likes"</span>);
</div></code></pre>

<hr>

<p>解法一：</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookUp</span>(<span class="hljs-params">firstName, prop</span>)</span>{
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以下</span>
</div><div class="hljs-line"> <span class="hljs-keyword">var</span> hasName = <span class="hljs-literal">false</span>,hasprop = <span class="hljs-literal">false</span>,propValue;
</div><div class="hljs-line">   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,len=contacts.length; i&lt;len; i++){
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">if</span> (hasName &amp;&amp; hasprop) <span class="hljs-keyword">break</span>;
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> contacts[i]) {
</div><div class="hljs-line">            <span class="hljs-keyword">if</span> (contacts[i].firstName == firstName) {
</div><div class="hljs-line">                hasName = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">                <span class="hljs-keyword">if</span> (key == prop) {
</div><div class="hljs-line">                    hasprop = <span class="hljs-literal">true</span>;
</div><div class="hljs-line">                    propValue = contacts[i][key];
</div><div class="hljs-line">                } <span class="hljs-keyword">else</span> {
</div><div class="hljs-line">                    <span class="hljs-keyword">continue</span>;
</div><div class="hljs-line">                }
</div><div class="hljs-line">                <span class="hljs-keyword">break</span>;
</div><div class="hljs-line">            } 
</div><div class="hljs-line">        }
</div><div class="hljs-line">   }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line">   <span class="hljs-keyword">if</span> (hasName) {
</div><div class="hljs-line">        <span class="hljs-keyword">if</span> (hasprop) {
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> propValue;
</div><div class="hljs-line">        } <span class="hljs-keyword">else</span> {
</div><div class="hljs-line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"No such property"</span>;
</div><div class="hljs-line">        }
</div><div class="hljs-line">   } <span class="hljs-keyword">else</span> {
</div><div class="hljs-line">     <span class="hljs-keyword">return</span> <span class="hljs-string">"No such contact"</span>;
</div><div class="hljs-line">   }
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以上</span>
</div><div class="hljs-line">}
</div></code></pre>

<hr>

<p>最优解法：</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookUp</span>(<span class="hljs-params">firstName, prop</span>) </span>{
</div><div class="hljs-line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; contacts.length; i++) {
</div><div class="hljs-line">                    <span class="hljs-keyword">if</span>(contacts[i].firstName === firstName) {
</div><div class="hljs-line">                        <span class="hljs-keyword">return</span> contacts[i][prop] || <span class="hljs-string">"No such property"</span>
</div><div class="hljs-line">                    }
</div><div class="hljs-line">                }
</div><div class="hljs-line">                <span class="hljs-keyword">return</span> <span class="hljs-string">"No such contact"</span>
</div><div class="hljs-line">            }
</div></code></pre>

<hr>

<p>我的解法： <br>
btw 我的解法在.hasOwnProperty 不行，记录下来下次再看看。</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookUp</span>(<span class="hljs-params">firstName, prop</span>)</span>{
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以下</span>
</div><div class="hljs-line">  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;contacts,length; i++){
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(contacts[i].firstName === firstName){
</div><div class="hljs-line">       <span class="hljs-keyword">if</span>(contacts[i].hasOwnProperty(prop)){
</div><div class="hljs-line">         <span class="hljs-keyword">return</span> contacts[i][prop];
</div><div class="hljs-line">       }
</div><div class="hljs-line">    }
</div><div class="hljs-line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"No such contact"</span>;
</div><div class="hljs-line">  } 
</div><div class="hljs-line"><span class="hljs-comment">// 请把你的代码写在这条注释以上</span>
</div><div class="hljs-line">}
</div></code></pre></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/10/24/freeCodeCamp 前端开发课程 220（Profile Lookup）/" data-id="ck67be8gs0001acvam61hu95t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch3-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/25/红宝书阅读笔记ch3-2/" class="article-date">
  <time datetime="2019-09-25T05:49:35.554Z" itemprop="datePublished">2019-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch3-2</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style></style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch3-2">红宝书阅读笔记ch3-2</h1>



<h3 id="操作符">操作符</h3>

<p>操作符用于操作数据值，包括算术操作符、位操作符、关系操作符和相等操作符。 <br>
ECMAScript操作符适用于很多值，例如字符串、数字值、布尔值，甚至对象。</p>



<h4 id="一元操作符">一元操作符</h4>

<ul><li><p>递增和递减操作符</p>

<ul>
<li><p>递增和递减操作符，有前置型和后置型。</p></li>
<li><p>执行前置型递增和递减操作时，变量的值都是在语句求值以前改变的。</p></li>
<li><p>后置型递增和递减操作是在它们的语句被求值之后才执行的。  </p></li></ul></li>
<li><p>一元加和减操作符</p>

<ul>
<li><p>一元加操作符以一个加号(+)表示，可用以加对非数值进行转换。</p></li>
<li><p>一元减操作符以一个加号(-)表示，同样也可以用于对非数值的转换，然后再将数值转换为负数。  </p></li></ul></li>
<li><p>位操作符，简单点说就操作二进制的运算。</p>

<ul>
<li><p>按位非（NOT），由一个波浪线（~）表示，返回二进制数值的反码。</p></li>
<li><p>按位与（AND），由一个和号字符（&amp;）表示，它有两个操作数，将两个数值的每一位对齐，1 0 得0,0 1得0,1 1得1。</p></li>
<li><p>按位或（OR）,由一个竖线符号（|）表示，同样也有两个操作数，在两个位有一个位是1就返回1，而只有两个0才返回0。</p></li>
<li><p>按位异或（XOR），由一个插入符号（^）表示，也有两个操作数，1 1得0,1 0得1,0 1得1,0 0得0。</p></li>
<li><p>左移操作符由两个小于符号（&lt;&lt;）表示，这个操作符会将数值的所有位向左移动指定的位数，左移会以0来填充空位。</p></li>
<li><p>有符号的右移操作符由两个大于号（&gt;&gt;）表示，将数值向右移动，但保留符号位。</p></li>
<li><p>无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示，这个操作符会将所有的32位都向右移动，对于正数来说有符号右移和无符号右移相同，但是对于负数来说无符号右移会把负数的二进制码当成正数的二进制码，而且负数以其绝对值的二进制补码形式表示，会导致无符号右移后结果会非常大。</p></li></ul></li>
</ul>



<h4 id="布尔操作符">布尔操作符</h4>

<p>布尔操作符有三个：NOT、AND、OR。</p>

<ul><li><p>逻辑非操作符由一个叹号（！）表示，可以应用于所有数据类型。无论这个值是什么类型，这个操作符都会返回一个布尔值。逻辑非会先将值转换为布尔值，再将其求反。</p>

<ul>
<li><p>转换规则：</p></li>
<li><p>如果操作数是一个对象，返回false；</p></li>
<li><p>如果操作数是一个空字符串，返回true；</p></li>
<li><p>如果操作数是一个非空字符串，返回false；</p></li>
<li><p>如果操作数是数值0，返回true；</p></li>
<li><p>如果操作数是任意非0数值（包括Infinity），返回false；</p></li>
<li><p>如果操作数是null,返回true；</p></li>
<li><p>如果操作数是Nan，返回true;</p></li>
<li><p>如果操作数是undefined,返回true。</p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">alert(!<span class="hljs-literal">false</span>);          <span class="hljs-comment">//返回true</span>
</div><div class="hljs-line">alert(!<span class="hljs-string">"blue"</span>;          <span class="hljs-comment">//返回false</span>
</div><div class="hljs-line">alert(!<span class="hljs-number">0</span>);              <span class="hljs-comment">//返回true</span>
</div></code></pre>

<ul><li><p>逻辑与操作符由两个和号（&amp;&amp;）表示，有两个操作数，真真为真，真假为假，假真为假，假假为假，可应用于所有类型的操作数。  </p>

<ul>
<li><p>在有一个操作数不是布尔值的情况下，逻辑与就不一定返回布尔值；此时它遵循以下规则：</p></li>
<li><p>如果第一个操作数是对象，则返回第二个数;</p></li>
<li><p>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；</p></li>
<li><p>如果两个操作数都是对象，则返回第二个操作数；</p></li>
<li><p>如果第一个操作数是null，则返回null；</p></li>
<li><p>如果第一个操作数是NaN，则返回NaN；</p></li>
<li><p>如果第一个操作数是undefined，则返回undefined；</p></li>
<li><p>逻辑与操作属于短路操作，即第一个是为false，那么就不会判断第二个是真还是假的了，它会直接返回false，而不会判断第二个操作数。   </p></li></ul></li>
<li><p>逻辑或操作符由两个竖线符号（||）表示，有两个操作数，真真为真，真假为真，假真为真，假假为假。</p>

<ul>
<li><p>如果有一个操作数不是布尔值，逻辑或不一定返回布尔值，遵循规则如下：</p></li>
<li><p>如果第一个操作数是对象，则返回第一个操作数；</p></li>
<li><p>如果第一个操作数的求值结果为false，则返回第二个操作数；</p></li>
<li><p>如果两个操作数都是对象，则返回第一个操作数；</p></li>
<li><p>如果两个操作数是null，则返回null；</p></li>
<li><p>如果两个操作数是NaN，则返回NaN；</p></li>
<li><p>如果两个操作数是undefined，则返回undefined。  </p></li>
<li><p>逻辑或同样也是短路操作，如果一个操作数的值为true，那么就不会判断第二个操作数的值了。通过这一点我们可以用来避免给变量赋值为null或undefined值。  </p></li></ul></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> myObject = preferredObject || backupObject;
</div></code></pre>



<h4 id="乘性操作符">乘性操作符</h4>

<ul><li><p>ECMAScript定义了三个乘性操作符，乘法（*）、除法（/）和求模（%），与其他语言用途类型，只是操作数为非数值的情况下会执行自动类型转换，也就是空字符串将被当做0，布尔值true会被当做0。</p></li>
<li><p>其他类型的转换规自行看书，P47。</p></li>
</ul>



<h4 id="加性操作符">加性操作符</h4>

<p>在ECMAScript中加和减除了简单的算术运算外还有一系列的特殊操作。</p>

<ul><li><p>加法，用（+）表示</p>

<ul>
<li><p>如果操作数两个都是数值，执行常规的加法计算；</p></li>
<li><p>如果是NaN、Infinity、-Infinity那么返回的结果也是这三种数据类型。</p></li>
<li><p>如果+0、-0那么返回的还是0。</p></li>
<li><p>如果有两个操作数都是字符串，则将第二个操作数和第一个操作数拼接起来。</p></li>
<li><p>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接起来。</p></li>
<li><p>如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串，然后再应用前面关于字符串的规则。对于null和undefined，则分别调用函数String()取得字符串”null”和”undefined”。  </p></li></ul></li>
<li><p>减法操作符，（-）</p>

<ul>
<li><p>如果两个操作数都是数值，则执行常规的算术减法并返回结果。</p></li>
<li><p>正无穷减正无穷的结果是NaN，负无穷减负无穷的结果是负无穷。</p></li>
<li><p>零减零的结果是零。</p></li>
<li><p>如果有一个操作数是字符串、布尔值、null、或undefined，则先在后台调用Number()函数将其转换为数值，然后在根据前面的规则执行减法运算。如转换的是NaN，则减法的结果就是NaN。</p></li>
<li><p>如果有一个操作数是对象的话，则调用对象的valueOf()方法取得表示该对象的数值。如果得到的是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其的toString()方法并将得到字符串转换为数值。</p></li></ul></li>
</ul>



<h4 id="关系操作符">关系操作符</h4>

<p>小于(&lt;)、大于(&gt;)、小于等于（&lt;=）和大于等于（&gt;=）这几个关系操作符用于对两个值的比较，并返回一个布尔值。</p>

<ul><li><p>如何两个操作数都是数值，则执行数值比较。</p></li>
<li><p>如果两个都是字符串，则比较两个字符串对应的字符编码值。</p></li>
<li><p>如果有一个操作数是数值，则将另一个操作数转换为数值再执行数值比较。</p></li>
<li><p>如果有一个操作数是对象，则先调用这个对象的valueOf（）方法，用得到的结果按照前面的规则进行比较，如没有valueOf（）方法，则调用toString（）方法，并用得到的结果根据前面的规则执行比较。</p></li>
</ul>



<h4 id="相等操作符">相等操作符</h4>

<p><strong>相等</strong>和<strong>不相等-</strong>–先转换再比较 <br>
<strong>全等</strong>和<strong>不全等</strong>—仅比较不转换  </p>

<ul><li><p>相等操作符由两个等号（==）表示，如果两个操作数相等，则返回true。而不相等操作符由叹号后跟等号（！=）表示，如果两个操作数不相等，则返回true。这两个操作符都会先转换操作数（俗称强制转型），然后再比较它们的相等性。  </p>

<ul>
<li><p>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—false转换为0，而true转换为1；</p></li>
<li><p>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先把字符串转换为数值；</p></li>
<li><p>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf（）方法，用得到的基本类型按照前面的规则进行比较；</p></li>
<li><p>null和undefined是相等的；</p></li>
<li><p>要比较相等性之前，不能将null和undefined转换成其他任何值。</p></li>
<li><p>NaN和任何类型的值都不相等，包括它自己。</p></li>
<li><p>如果两个操作数都是对象，则比较它们是不是同一个对象。  </p></li></ul></li>
<li><p>全等和不全等 <br>
全等和不全等，除了不转换操作数之外，其比较规则与相等和不相等一样。</p>

<ul>
<li><p>全等操作符由三个等号（===）表示。</p></li>
<li><p>不全等操作符由一个叹号和三个等号（！===）表示。</p></li>
<li><p>需要注意的一点null和undefined是相等的，但不是全等的，因为它们不是一个类型。</p></li></ul></li>
</ul>



<h4 id="条件操作符">条件操作符</h4>

<p>ECMAScript的条件操作符与Java的条件操作符语法相同。</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> variable = boolean_expression ? true_value : false_value;
</div></code></pre>



<h4 id="赋值操作符">赋值操作符</h4>

<p>简单的赋值操作符由等于号（=）表示，其作用就是把右侧的值赋给左侧的变量。除此之外还可以在等于号前面添加 加减乘除、取模操作符或位操作符完成复合操作。</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> num=<span class="hljs-number">10</span>;
</div><div class="hljs-line">num +=<span class="hljs-number">10</span>;   <span class="hljs-comment">//等同于num = num +10</span>
</div></code></pre>



<h4 id="逗号操作符">逗号操作符</h4>

<p>逗号操作符多用于声明多个变量；除此之外逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式的最后一项。</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><div class="hljs-line">    <span class="hljs-keyword">var</span> num1=<span class="hljs-number">1</span>,num2=<span class="hljs-number">2</span>,num3=<span class="hljs-number">3</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">var</span> num = (<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>);  <span class="hljs-comment">//num的值为0</span>
</div></code></pre></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/09/25/红宝书阅读笔记ch3-2/" data-id="ck67be8h80007acvaaoayxa1r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-红宝书阅读笔记ch3-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/21/红宝书阅读笔记ch3-1/" class="article-date">
  <time datetime="2019-09-21T02:22:38.742Z" itemprop="datePublished">2019-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><title>红宝书阅读笔记ch3-1</title><meta charset="utf-8"><link href="https://cdn.maxiang.io/res-min/themes/marxico.css" rel="stylesheet"><style></style></head><body><div id="preview-contents" class="note-content">
                        
                    



<h1 id="红宝书阅读笔记ch3-1">红宝书阅读笔记ch3-1</h1>

<p>基本概念-ECMAScript基础语法 <br>
语法、关键字和保留字、 变量、 数据类型</p>

<h3 id="语法">语法</h3>

<ol><li rel="1"><p>区分大小写，ECMAScript中的一切都区分大小写。  </p></li>
<li rel="2"><p>标识符，就是指变量、函数、属性的名字，标识符有以下几个规则：</p>

<ul>
<li><p>第一个字符必须是一个字母、下划线(_)、或一个美元符号；</p></li>
<li><p>其他字符可以是字母、下划线、美元符号或数字；  </p></li>
<li><p>ECMAScript标识符采用驼峰大小格式，也就是第一个字母小写，剩下的每个单词的首字母大写，例如：firstSecond、myCar、doSomethingImportant。</p></li>
<li><p>不能把关键字、保留字、true、false和null用作标识符。</p></li>
<li><p>可以包含扩展的ASCII或Unicode字母字符。但是不建议这样做，因为很容易和英文混淆。  </p></li></ul></li>
<li rel="3"><p>注释 <br>
//单行注释 <br>
/* 这是一个多行注释 */</p></li>
<li rel="4"><p>严格模式 <br>
使用 “use strict” 指令 <br>
“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。 <br>
它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。 <br>
“use strict” 的目的是指定代码在严格条件下执行。 <br>
严格模式下你不能使用未声明的变量。 <br>
Note    支持严格模式的浏览器: <br>
Internet Explorer 10 +、 Firefox 4+ Chrome 13+、 Safari 5.1+、 Opera 12+。 <br>
为什么使用严格模式: <br>
-消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;  </p>

<ul>
<li><p>消除代码运行的一些不安全之处，保证代码运行的安全；  </p></li>
<li><p>提高编译器效率，增加运行速度；  </p></li>
<li><p>为未来新版本的JavaScript做好铺垫。  </p></li></ul></li>
</ol>



<pre class="prettyprint hljs-dark"><code class="language-vbscript-html hljs"><div class="hljs-line"><span class="xml">    <span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>使用 "use strict":<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>不允许使用未定义的变量。<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>浏览器按下 F12 开启调试模式，查看报错信息。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-meta"></span></span></span>
</div><div class="hljs-line"><span class="xml">    "use strict";</span>
</div><div class="hljs-line"><span class="xml">    x = <span class="hljs-number">3.14</span>;   <span class="hljs-comment">// 报错 (x 未定义)</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml"></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
</div><div class="hljs-line"><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
</div></code></pre>

<ol start="5"><li rel="5"><p>语句  </p>

<ul>
<li><p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。</p></li>
<li><p>在控制语句中使用代码块可以让编程意图更加清晰。</p></li></ul></li>
</ol>

<hr>



<h3 id="关键字和保留字">关键字和保留字</h3>

<ul><li><p>关键字用于表示控制语句的开始和结束或者执行特定的规则。</p></li>
<li><p>关键字不能用在标识符。</p></li>
</ul>

<table><tbody><tr style="font-weight:bold">  <td>break</td>  <td>do</td>  <td>instanceof</td>  <td>typeof</td></tr><tr>  <td>case</td>  <td>else</td>  <td>new</td>  <td>var</td></tr><tr>  <td>catch</td>  <td>finally</td>  <td>return</td>  <td>void</td></tr><tr>  <td>continue</td>  <td>for</td>  <td>switch</td>  <td>while</td></tr><tr>  <td>debugger</td>  <td>function</td>  <td>this</td>  <td>with</td></tr><tr>  <td>default</td>  <td>if</td>  <td>throw</td>  <td></td></tr><tr>  <td>delete</td>  <td>in</td>  <td>try</td>  <td></td></tr></tbody></table>

<ul><li><p>保留字是一组不能用作标识符的字符，尽管现在这些保留字在这门语言中没有特定的用途但将来可能会用作关键字。</p></li>
</ul>

<table><tbody><tr style="font-weight:bold">  <td>abstract</td>  <td>enum</td>  <td>int</td>  <td>short</td></tr><tr>  <td>boolean</td>  <td>export</td>  <td>interface</td>  <td>static</td></tr><tr>  <td>byte</td>  <td>extends</td>  <td>long</td>  <td>super</td></tr><tr>  <td>…</td>  <td></td>  <td></td>  <td></td></tr></tbody></table>

<hr>



<h3 id="变量">变量</h3>

<ul><li><p>ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任意类型的数据。</p></li>
<li><p>定义变量时要使用var操作符，后跟一个变量名，如下所示： <br>
var message; <br>
这行代码定义了一个名为message的变量，该变量可以用来保存任何值，像这样未经过初始化的变量，会保存一个特殊的值—undefined。</p></li>
<li><p>ECMAScript也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值，如下所示： <br>
var message = “hi”;</p></li>
<li><p>在变量message中保存一个字符串值”hi”。像这样初始变量并不会把它标识为字符串类型；初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型，如下所示： <br>
 var message = “hi”; <br>
message = 100;                                //有效，但不推荐</p></li>
<li><p>如果在函数中使用var定义一个变量 ，那么这个变量在函数退出后就会被销毁。</p></li>
<li><p>在函数中省略var操作符定义的变量，只要调用了一次该函数，该变量就会变成全局变量，但是这样的方法不被推荐，因为在局部作用域中定义的全局变量很难维护。</p></li>
<li><p>可以使用一条语句定义多个变量，只要把每个变量用逗号分隔开即可； <br>
var message=”hi”; <br>
found=false; <br>
age=29;</p></li>
<li><p>在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。</p>

<hr></li>
</ul>



<h3 id="数据类型">数据类型</h3>

<ul><li><p>ECMAScript中有五种基本数据类型：Undefined、Null、Boolean、Number和String。</p></li>
<li><p>还有一种复杂数据类型—Object，Object本质上是一组无序的名值对组成。  </p>

<ol>
<li rel="1"><p>typeof操作符 <br>
typeof操作符是用来检测给定变量的数据类型，对一个值使用typeof可能返回下列某个字符串：</p>

<div class="checklist"><div class="checklist-item"><input type="checkbox"> “undefined”—如果这个值未定义;</div><div class="checklist-item"><input type="checkbox"> “boolean”—如果这个值是布尔值；</div><div class="checklist-item"><input type="checkbox"> “string”—如果这个值是字符串；</div><div class="checklist-item"><input type="checkbox"> “number”—如果这个值是数值；</div><div class="checklist-item"><input type="checkbox"> “object”—如果这个值是对象或者是null;</div><div class="checklist-item"><input type="checkbox"> “function”—如果这个值是函数。  </div></div></li></ol></li>
</ul>



<pre class="prettyprint hljs-dark"><code class="language-JavaScript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> message=<span class="hljs-string">"some string"</span>;
</div><div class="hljs-line">alert(<span class="hljs-keyword">typeof</span> message);                  <span class="hljs-comment">//"String"</span>
</div><div class="hljs-line">alert( (<span class="hljs-keyword">typeof</span> message) );              <span class="hljs-comment">//"String"</span>
</div><div class="hljs-line">alert(<span class="hljs-keyword">typeof</span> <span class="hljs-number">95</span>);                       <span class="hljs-comment">//"String"</span>
</div></code></pre>

<blockquote>
  <h4 id="注意"><em>注意</em>：</h4>
  
  <p><em>1.调用typeof null会返回”object“，因为特殊值null被认为是一个空的对象引用。</em> <br>
  <em>2.Safari 5及之前的版本、Chrome 7 及之前版本在对正则表达式调用typeof操作符时会返回”function”，而其他浏览器在这种情况下会返回”object”。</em> <br>
  <em>3.从技术角度上来说，函数在ECMAScript中是对象，而不是一种数据类型。然而，函数也确实有些特殊的属性，因此通过typeof操作符来区分函数和其他对象是有必要的。</em></p>
</blockquote>

<ol start="2"><li rel="2"><p>undefined类型  </p>

<ul>
<li><p>Undefined类型只有一个值，即特殊的undefined。</p></li>
<li><p>在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。</p></li>
<li><p>声明变量的值为undefined，与声明变量未初始化的值，相等。</p></li>
<li><p>包含undefined值的变量与尚未定义的变量还是有不同的。</p></li></ul></li>
</ol>



<pre class="prettyprint hljs-dark"><code class="language-JavaScript hljs"><div class="hljs-line"><span class="hljs-keyword">var</span> message;
</div><div class="hljs-line">alert(message==<span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span>
</div><div class="hljs-line"><wbr>
</div><div class="hljs-line"><span class="hljs-keyword">var</span> message=<span class="hljs-literal">undefined</span>;
</div><div class="hljs-line">alert(message==<span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span>
</div></code></pre>

<ol start="3"><li rel="3"><p>Null类型</p>

<ul>
<li><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是null。</p></li>
<li><p>从逻辑的角度来看，null值表示一个空对象指针，这也是typeof操作符检测null值会返回”object”的原因。</p></li>
<li><p>如果定义的变量准备在将来保存一个对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要检查null的值就可以知道相应的变量是否已经保存了一个的对象的引用。</p></li>
<li><p>undefined值派生自null值，因此ECMA-262规定对它们的相等性测试要返回true。</p></li>
<li><p>不要将一个对象的值显式的设置为undefined。</p></li>
<li><p>只要在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样不仅可以体现null作为空对象指针的惯例，还能进一步区分null和undefined。</p></li></ul></li>
<li rel="4"><p>Boolean 类型</p>

<ul>
<li><p>Boolean 类型只有两个字面值：true和false。</p></li>
<li><p>Boolean 类型的字面值区分大小写，</p></li>
<li><p>ECMAScript中所有的值都有与这两个Boolean值等价的值。要将一个值装换为对应的Boolean值，可以调用转型函数Boolean()。</p></li>
<li><p>控制语句能将其他的数据类型转换成Boolean类型。</p></li></ul></li>
</ol>

<table><tbody><tr style="font-weight:bold">  <td align="center">数据类型</td>  <td align="center">转换为true的值</td>  <td align="center">转换为false的值</td></tr><tr>  <td align="center">Boolean</td>  <td align="center">true</td>  <td align="center">false</td></tr><tr>  <td align="center">String</td>  <td align="center">任何非空字符串</td>  <td align="center">“” （空字符串）</td></tr><tr>  <td align="center">Number</td>  <td align="center">任何非零数字值（包括无穷大）</td>  <td align="center">0和NaN</td></tr><tr>  <td align="center">Object</td>  <td align="center">任何对象</td>  <td align="center">null</td></tr><tr>  <td align="center">Undefined</td>  <td align="center">n/a</td>  <td align="center">undefined</td></tr></tbody></table>



<pre class="prettyprint hljs-dark"><code class="language-JavaScript hljs"><div class="hljs-line">    <span class="hljs-keyword">var</span> message=<span class="hljs-string">"Hello world"</span>;
</div><div class="hljs-line">    <span class="hljs-keyword">if</span>(message){                   
</div><div class="hljs-line">        alert(<span class="hljs-string">"Value is true"</span>);   
</div><div class="hljs-line">    }
</div></code></pre>

<ol start="5"><li rel="5"><p>Number 类型</p>

<ul>
<li><h5 id="浮点数值">浮点数值</h5></li>
<li><p>Number 类型用来表示整数和浮点数值。</p></li>
<li><p>支持不同的数值字面值格式包括十进制整数、十六进制整数、八进制整数。</p></li>
<li><p>八进制字面值第一位必须是零（0），然后八进制数字序列（0~7）。如果字面数值超出了范围，那么前导零将被忽略，后面的数值当做十进制解析。</p></li>
<li><p>八进制字面值在严格模式下是无效的，会导致支持该模式的JavaScript引擎抛出错误。</p></li>
<li><p>十六进制字面值前面两位是0x，后跟任何十六进制数字（0~9即A~F）。其中A~F可以大写也可以小写。</p></li>
<li><p>浮点数值,就是该数值必须包括一个小数点，并且小数点后面必须至少有一位数字。小数点前面可以没有整数。</p></li>
<li><p>ECMAScript会选择性的将浮点数值转换成整数。</p></li>
<li><p>对于那些极大或极小的数值，可以用科学计数法。</p></li>
<li><p>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如0.1加上0.2的结果不是0.3，而是0.30000000000000004。</p></li>
<li><h5 id="数值范围">数值范围</h5></li>
<li><p>数值范围，ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE，这个值是5e-324，能够表示最大数值保存在Number.MAX_VALUE，这个值是1.7976931348623157e+308。</p></li>
<li><p>如果某次计算得到了超出JavaScript数值范围的值，那么这个数值将被自动转换为特殊的Infinity值。正数是正无穷，负数是负无穷。Infinity不能参与计算。</p></li>
<li><p>想要确定某个数值是否超过数值范围，可以使用isFinite()函数，这个函数在参数位于最小和最大数值之间会返回true。</p></li>
<li><h5 id="nan">NaN</h5></li>
<li><p>NaN，即非数值（Not a Number），是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况，这样就不会报错了。</p></li>
<li><p>NaN本身有两个特点，首先任何涉及到NaN的操作都会返回NaN。其次，NaN与任何值都不相等包括它自己。</p></li>
<li><p>isNaN()函数用于确定参数是否“不是数值”。 isNaN()函数在接收到一个参数后，会尝试将这个值转换为数值。某些不是数值的值会直接转换成数值，例如字符串”10”或Boolean值。而任何不能转换为数值的值都会导致这个函数返回true。</p></li>
<li><h5 id="数值转换">数值转换</h5></li>
<li><p>将非数值转换为数值的方法有三个，分别是Number（）、parseInt（）和parseFloat（）。</p></li></ul></li>
<li rel="6"><p>String类型</p>

<ul>
<li><p>在ECMAScript字符串的表达方式可以是双引号也可以是单引号，只是用单引号开始也必须用单引号结束，双引号同理。</p></li>
<li><p>字符字面量==转义字符，也就是反斜杠。</p></li>
<li><p>ECMAScript的字符串不可变，要改变某个变量保存的字符串，就要销毁原来的字符串，再用一个包含新值的字符串来填充该变量。</p></li>
<li><p>将一个值转换为String 的方法有两个，toString（）和String（）。</p></li>
<li><p>除了null和undefined类型外，其他的类型都有toString（）方法。</p></li></ul></li>
<li rel="7"><p>Object类型</p>

<ul>
<li><p>ECMAScript中的对象其实就是一组数据和功能的集合。</p></li>
<li><p>Object 类型是所有它的实例的基础。</p></li></ul></li>
</ol></div></body></html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.1n40.cn/2019/09/21/红宝书阅读笔记ch3-1/" data-id="ck67be8h40005acva595s5lhj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/04/看书和看视频学习那个会更好？/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/02/04/知识边界/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/20/红宝书阅读笔记ch5-3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/16/红宝书阅读笔记ch5-2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/11/29/红宝书阅读笔记ch5-1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 ian<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>